# Algoritmos_problemas

[![Fácil](https://img.shields.io/badge/Fácil-✔️-brightgreen)](#)
[![Médio](https://img.shields.io/badge/Médio-✔️-yellow)](#)
[![Difícil](https://img.shields.io/badge/Difícil-✔️-red)](#)

Este repositório contém explicações e links de estudo sobre diversos algoritmos e problemas clássicos de programação.  
O objetivo é servir como referência rápida para aprendizado e prática de algoritmos em Ruby.

---

## 1 - Algoritmo de Busca Linear (Fácil)

A Busca Linear percorre cada elemento da lista sequencialmente até encontrar o valor desejado.

- Funciona em listas ordenadas ou não ordenadas.  
- Simples de implementar e fácil de entender.  
- **Complexidade:** O(n)

[Referência de estudo](https://www.geeksforgeeks.org/dsa/linear-search/)

---

## 2 - Pesquisa Binária (Fácil)

A pesquisa binária é um algoritmo eficiente para buscar um elemento em uma lista **ordenada**.  

- Divide a lista ao meio a cada passo.  
- Funciona de forma **iterativa** ou **recursiva**.  
- **Complexidade:** O(log n)

[Referência de estudo](https://www.geeksforgeeks.org/dsa/binary-search/)

---

## 3 - Bubble Sort (Fácil)

O Bubble Sort percorre a lista várias vezes, trocando elementos adjacentes fora de ordem.  

- Simples e didático, mas ineficiente para listas grandes.  
- **Complexidade:** O(n²)

[Referência de estudo](https://www.geeksforgeeks.org/dsa/bubble-sort-algorithm/)

---

## 4 - Counting Sort (Médio)

O Counting Sort ordena números inteiros em um intervalo conhecido sem usar comparações.  

- Conta a frequência de cada valor.  
- Reconstrói a lista ordenada a partir das contagens.  
- **Complexidade:** O(n + k)

[Referência de estudo](https://www.geeksforgeeks.org/dsa/counting-sort/)

---

## 5 - Maximize Array (Médio)

O problema consiste em reorganizar ou escolher elementos de um array para **maximizar uma função** (ex.: soma após k negações).  

- Pode envolver **ordenação e manipulação de sinais**.  
- **Complexidade:** O(n log n)  

[Referência de estudo](https://www.geeksforgeeks.org/dsa/maximize-array-sum-after-k-negations-using-sorting/)

---

## 6 - Minimum Product (Médio)

Encontrar o produto mínimo de elementos selecionados em um array.  

- Geralmente envolve **análise de sinais e ordenação**.  
- **Complexidade:** O(n log n)  

[Referência de estudo](https://www.geeksforgeeks.org/dsa/minimum-product-subset-array/)

---

## 7 - Minimum Spanning Tree (Difícil)

Algoritmo para encontrar uma árvore que conecta todos os vértices de um grafo com **peso total mínimo**.  

- Exemplos: **Kruskal**, **Prim**.  
- **Complexidade:** O(E log V)  

[Referência de estudo](https://www.geeksforgeeks.org/dsa/problem-solving-minimum-spanning-trees-kruskals-prims/)

---

## 8 - Minimum Sum (Médio)

Encontrar a soma mínima possível ao escolher pares de elementos de um array.  

- Envolve **ordenar e agrupar pares estrategicamente**.  
- **Complexidade:** O(n log n)  

[Referência de estudo](https://www.geeksforgeeks.org/dsa/minimum-sum-choosing-minimum-pairs-array/)

---

## 9 - Roman to Integer (Fácil)

Converter números romanos em inteiros.  

- Envolve **mapear caracteres para valores** e processar regras de subtração.  
- **Complexidade:** O(n)  

[Referência de estudo](https://leetcode.com/problems/roman-to-integer/description/)

---

## 10 - Find Future (Difícil)

Resolver consultas para encontrar **a data mais próxima no futuro** em relação a uma dada data.  

- Pode envolver **busca binária ou estruturas de dados eficientes**.  
- **Complexidade:** Depende da implementação, geralmente O(log n) por consulta.  

[Referência de estudo](https://www.geeksforgeeks.org/dsa/queries-to-find-the-future-closest-date/)
